
<!-- A. CAPÇALERA I INITS (NO TOCAR) ============================== -->
<!DOCTYPE html>
<head>
    <title id="titol"></title>
    <link rel="icon" type="image/x-icon" href=../img/favicon.png>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="css/main.css" />
</head>

<script>
window.texme = {
    renderOnLoad: false,
    style: 'none',
    markdownURL: 'js/marked/marked.min.js',
    MathJaxURL: 'js/mathjax/es5/tex-mml-chtml.js'
}
</script>
<script src="../js/texme/texme.js"></script>

<!-- FI NO TOCAR ================================================== -->




<!-- B. ENUNCIAT ================================================== -->
<textarea id="enunciat">

Introdueix aquí la teva permutació: <br/>
[[i1]]

Introdueix aquí la teva resposta: <br/>
[[i2]]

</textarea>
<!-- FI ENUNCIAT ================================================== -->







<!-- C. SCRIPT ==================================================== -->
<script>


// # 1. CONSTANTS (actualitzar) ---------------------------------------
const titol = "Comprovador exercici UT07 - Exercici 05";
const puntuacions = ["",
];



// # 2. PARÀMETRES ====================================================

// ## 2.1. DECLARACIÓ (actualitzar) -----------------------------------
let txtav = "";
let ptos = 0;

const preguntes = 
[
    [
        "Quina és la diferència fonamental en el principi de regulació entre una font d'alimentació lineal i una de commutada?",
        "La lineal utilitza un transformador més petit, mentre que la commutada en utilitza un de més gran.",
        "La lineal dissipa l'excés de potència en un transistor en zona activa, mentre que la commutada commuta transistors en tall i saturació.",
        "La lineal només pot treballar amb tensions d'entrada continues, mentre que la commutada treballa amb alterna.",
        "La lineal té un rendiment superior al 90%, mentre que la commutada té un rendiment inferior al 50%."
    ],
    [
        "Quin és el rang d'eficiència típic per a una font d'alimentació commutada (SMPS)?",
        "30-60%",
        "50-70%",
        "70-95%",
        "85-99%"
    ],
    [
        "Quin bloc funcional és característic d'una font commutada i no es troba en una font lineal?",
        "La porta NAND",
        "El rectificador de sortida",
        "El commutador (inversor) que treballa a alta freqüència",
        "El filtre de sortida"
    ],
    [
        "Per què les fonts commutades poden ser més petites i lleugeres que les lineals?",
        "Perquè utilitzen condensadors de menor capacitat.",
        "Perquè no necessiten transformador.",
        "Perquè el transformador treballa a alta freqüència i pot ser de ferrita, molt més petit.",
        "Perquè prescindeixen del filtre de sortida."
    ],
    [
        "Quina família de circuits integrats és un exemple clàssic de regulador lineal de tres terminals per a tensió positiva?",
        "LM79xx",
        "LM317",
        "LM78xx",
        "UC3842"
    ],
    
    
    
    
    
    [
        "En quina aplicació és més adequada l'ús d'una font d'alimentació lineal per sobre d'una de commutada?",
        "En un ordinador personal, per la seva alta eficiència.",
        "En un carregador de telèfon mòbil, per la seva mida reduïda.",
        "En un equip d'àudio d'alta fidelitat, on el soroll elèctric (EMI) és crític.",
        "En un inversor solar, per la seva capacitat de gestionar grans potències."
    ],
    [
        "Quin instrument és el més adequat per visualitzar la forma d'ona del rissat (ripple) a la sortida d'una font commutada?",
        "Un multímetre en mode de tensió contínua.",
        "Una pinça amperimètrica.",
        "Un oscil·loscopi.",
        "Un analitzador d'espectre."
    ],
    [
        "Quina és la característica principal d'un convertidor commutat en configuració reductora (buck)?",
        "La tensió de sortida (Vout) és superior a la tensió d'entrada (Vin).",
        "La tensió de sortida (Vout) és inferior a la tensió d'entrada (Vin).",
        "La tensió de sortida (Vout) pot ser superior o inferior a Vin.",
        "La tensió de sortida (Vout) és igual a la tensió d'entrada (Vin) però amb canvi de polaritat."
    ],
    [
        "En un convertidor elevador (boost), com s'aconsegueix que la tensió de sortida sigui superior a la d'entrada?",
        "Mitjançant un transformador amb més espires al secundari.",
        "Emmagatzemant energia en una bobina i alliberant-la en sèrie amb la tensió d'entrada.",
        "Utilitzant un díode Zener per augmentar la tensió.",
        "Connectant diverses etapes de rectificació en cascada."
    ],
    [
        "Quina topologia de font commutada és capaç de regular la tensió de sortida tant si és inferior com superior a la tensió d'entrada?",
        "Convertidor buck (reductor).",
        "Convertidor boost (elevador).",
        "Convertidor buck-boost (flyback).",
        "Convertidor amb pont de díodes."
    ]
];

const solucions_test = [

2, 3, 3, 3, 3,
3, 3, 2, 2, 3

];
const opcions_test = [1, 2, 3, 4];

let permutacio = "";
const num_preg = solucions_test.length;
const num_resp = opcions_test.length;


// ## 2.2 FUNCIO (actualitzar) ----------------------------------------

function estableixParametres(){
    array = [/* p01, p02, p03, p04, p05 */]; // actualitzar entre []
    parametres = parametres.concat(array);  // no tocar aquesta línia
}




// # 3. CALCULS =======================================================

// ## 3.1 CALCUL VALORS (ACTUALITZAR) ---------------------------------
function calcula(){
    const permutacio = respostes [0];

    const permpreg = permutacio.split("_")[0];
    const permresp = permutacio.split("_")[1].split(".");
    const respostes_alumne = respostes [1].split("");

    const preg_ordenades = obtenirPermutacio(preguntes, permpreg);
    const sol_ordenades = obtenirPermutacio(solucions_test, permpreg);


    for (let i = 0; i < num_preg; i++){
        preg = preg_ordenades[i][0];
        txtav += "**" + (i+1) + ".** " + preg + "<br/>\n";

        let resp =
         obtenirPermutacio(preg_ordenades[i].slice(1), permresp[i]);

        let pr = permresp[i];
        let opcions_permutades = obtenirPermutacio(opcions_test, pr);

        let st = sol_ordenades[i];
        let opcio_correcta = opcions_permutades.indexOf(st) + 1;
        let opcio_marcada = lletraANombre(respostes_alumne[i]);
        let color = "black";
        let marcador = "";

        //debugger;

        for (let j = 0; j < num_resp; j++){
            a = j + 1;
            if (a === opcio_correcta && opcio_marcada > num_resp){
                color = "gray";
                marcador = "⇦";
            } else if (a != opcio_correcta && opcio_marcada > num_resp){
                color = "gray";
            } else if (a === opcio_correcta && a === opcio_marcada){
                color = "green";
                marcador = "⇦";
                ptos += 1;
            } else if (a === opcio_correcta && a != opcio_marcada){
                marcador = "⇦";
            } else if (a != opcio_correcta && a === opcio_marcada){
                color = "red";
                ptos -= 1/(num_resp-1);
            } else if (a != opcio_correcta && a != opcio_marcada){
            }
            txtav += '&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: ' +
             color + '"><i>' + nombreALletra(j+1) + "</i>)&nbsp;" +
             resp[j] + marcador + "</span><br/>\n"
            color = "black";
            marcador = "";
        } // fi for respostes
        txtav += "<br/>\n";
    } // fi for preguntes
} //fi calcula();





// # D. ENTRENADOR SERVERI ============================================


// # 1. VARIABLES GLOBALS =============================================

let txtEnunciat = "";   // l'enunciat de l'apartat B.
let parametres = [""];  // els paràmetres del punt 3.1.
let solucions = [""];   // els valors que ha donat el programa.
let respostes = [""];   // els valors que ha donat l'alumne.
let alumne = {
    nom: "",
    cicle: "CFGS Técnic Superior en sistemes electrotècnics i automatitzats",
    anys: "2024/2025"
}
let tlog = "";          // log que apareix al final de l'avaluació.



// # 2. FUNCIONS ======================================================


window.onload = function (){
    // txtEnunciat és una variable global
    txtEnunciat = document.getElementById("enunciat").value;
    renderEnunciat(txtEnunciat);
}

function renderEnunciat(){
    let txt = "";
    estableixParametres();
    txt = '<h1 align ="center">' + titol + "</h1>\n&nbsp;\n\n" +
          txtEnunciat;
    txt = exportarParametres(txt);
    txt = crearInputs(txt);
    txt = crearIdentificacio(txt);
    document.getElementById("enunciat").innerHTML = txt;
    document.getElementById("titol").innerText = titol;
    texme.renderPage();
}

function exportarParametres(txt){
    let patro = "", canvi = "";
    const fi = parametres.length;
    for (let i = 1; i < parametres.length; i++) {
        patro = "[[p" + i +"]]";
        canvi = l(parametres[i]);
        txt = txt.replace(patro, canvi);
    }
    return txt;
}

function crearInputs(txt){
    let patro = "", canvi = "";
    patro = "[[i1]]";
    canvi = '<input type="text" onwheel="return false;" ';
    canvi += 'id="i1" style="width: 300px">';
    txt = txt.replace(patro, canvi);
    patro = "[[i2]]";
    canvi = '<input type="text" onwheel="return false;" ';
    canvi += 'id="i2" style="width: 300px">';
    txt = txt.replace(patro, canvi);
    /*for (let i = 1; i < puntuacions.length; i++) {
        patro = "[[i" + i +"]]";
        canvi = '<input type="text" onwheel="return false;" ';
        canvi += 'id="i'+ i +'" style="width: 300px">';
        txt = txt.replace(patro, canvi);
    }*/
    return txt;
}

function crearIdentificacio(txt){
txt += `
<h2>Identificació de l'alumne</h2>

<form id="avalua" onsubmit="event.preventDefault() & avalua()">
    <label>Nom de l'alumne: </label>
    <input id="nom" style="width: 400px"/>
    <div>
        <input type="checkbox" id="informat" required/>
        <label>
            Entenc que al premer el botó avaluar no es pot tornar
            enrera.
        </label>
    </div>
    <br/>
    <div style="text-align: center;">
        <button type="submit" id="boto"
            style="font-size: 20px; color: #AA5050;">
            Avaluar
        </button>
    </div>
</form>
`; return txt;
}

function avalua(){
    importaRespostes();
    resetejar();
    renderAvaluacio();
}

function importaRespostes(){
    respostes[0] = document.getElementById("i1").value;
    respostes[1] = document.getElementById("i2").value;
    alumne.nom = document.getElementById("nom").value;
}

function resetejar(){
    const ppal = document.getElementsByTagName("main")[0];
    const body = ppal.parentNode;
    const textArea = body.appendChild(document.createElement("textarea"));
    body.removeChild(ppal);
    textArea.setAttribute("id", "avaluacio");
}

function renderAvaluacio(){
    let txt = "";
    txt += '<h1 align="center"> Avaluació</h1>\n' +
           '<h2 align="center" style="color: #888">' + titol +
           "</h2>\n&nbsp;\n\n"
    txt += [
    "## Presentació de resultats",
    "",
    "L'alumne **[[nom]]**, del [[cicle]] (any [[any]]) ha obtingut una",
    "qualificació de:",

    "> [[nota]]"
    ].join("\n") + "\n\n\n";

    txt = identificarAlumne(txt);
    txt = puntua(txt);

    console.log(txt);
    document.getElementById("avaluacio").innerHTML = txt;
    texme.renderPage();
}

function identificarAlumne(txt){
    txt = txt.replace("[[nom]]", alumne.nom);
    txt = txt.replace("[[cicle]]", alumne.cicle);
    txt = txt.replace("[[any]]", alumne.anys);
    return txt;
}

function puntua(txt){
    calcula();

    txt += txtav;

    let ptsAlumne = ptos, ptsTotal = num_preg;
    let canvi = "", patro = "";

    txt = txt.replace("[[nota]]", "S'han aconseguit: "+ xs(ptsAlumne, 2) +
        " punts de " + xs(ptsTotal, 2) + " possibles.\n>\n>" +
        "**Nota final: " + xs(ptsAlumne/ptsTotal*10, 2) + "**");

    /*
    let ptsAlumne = 0, ptsTotal = 0;
    let canvi = "", patro = "";
    let a = 0, b = 0;
    for (let i = 1; i < puntuacions.length; i++){
        a = respostes[i];
        b = solucions[i];
        ptsTotal += puntuacions[i];
        canvi =
            '<span style="border-bottom: 1px solid silver; padding: 0.2em 1em 0;">'
            + coma(a) + '</span>';
        if ((b*0.99) < a && a < (b*1.01)) {
            ptsAlumne += puntuacions[i];
            canvi +=
                ' <span style="color: green">(' +
                coma(b) +') OK (+' + puntuacions[i] + ')</span>';
        }else{
            canvi +=
                ' <span style="color: red;"> (' +
                coma(b) +')</span>';
        }
        patro = "[[i" + i + "]]";

        txt = txt.replace(patro, canvi);
    }
    txt = txt.replace("[[nota]]", "S'han aconseguit: "+ xs(ptsAlumne, 2) +
        " punts de " + xs(ptsTotal, 2) + " possibles.\n>\n>" +
        "**Nota final: " + xs(ptsAlumne/ptsTotal*10, 2) + "**");
    */
    return txt;
}












function aleat(min, max) { // enter aleat entre min i max (inclosos)
    const a = Math.ceil(min);
    const b = Math.floor(max);
    const c = Math.floor(Math.random() * (b - a + 1) + a);
    return c;
}

function triaElementMatriu (matriu){
    const aleat = Math.floor(Math.random() * (matriu.length));
    return matriu[aleat.toFixed(0)];
}

function factorial(n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

// Funció per obtenir la permutació d'un índex específic
function obtenirPermutacio(array, index) {
    let permutacio = [];
    let elements = array.slice(); // Copia de l'array per a evitar
                                  // modificar l'original
    let n = elements.length;

    // Calcular la permutació utilitzant factorials
    for (let i = 0; i < n; i++) {
        let fact = factorial(n - i - 1);
        let posicio = Math.floor(index / fact);
        permutacio.push(elements[posicio]);
        elements.splice(posicio, 1);
        index %= fact;
    }

    return permutacio;
}

function permutacions(array) {

    let resultat = [];

    // Funció recursiva per a generar les permutacions
    function generarPermutacions(actual, resta) {
        if (resta.length === 0) {
            resultat.push(actual);
        } else {
            for (let i = 0; i < resta.length; i++) {
                let actualNova = actual.concat(resta[i]);
                let restaNova = resta.slice(0, i).concat(resta.slice(i + 1));
                generarPermutacions(actualNova, restaNova);
            }
        }
    }

    generarPermutacions([], array);
    return resultat;
}


function atan(a){
    return Math.atan(a)*360/2/π;
}

function sin(a){
    return Math.sin(a*2*π/360);
}

function cos(a){
    return Math.cos(a*2*π/360);
}

function ln(a){
    return Math.log(a);
}

function cbi(x, y){ //complexe input en binomial
    const c = {};
    c.r = (x**2 + y**2)**0.5;
    c.φ = Math.atan2(y, x)*360/2/π;
    c.x = x;
    c.y = y;
    return c;
}

function cpol(r, φ){ //complexe input en polar (φ en graus)
    const c = {};
    c.r = r;
    c.φ = φ;
    c.x = r * cos(φ);
    c.y = r * sin(φ);
    return c;
}

function sumc(a, b){
    return cbi(a.x + b.x, a.y + b.y)
}

function restc(a, b){
    return cbi(a.x - b.x, a.y - b.y)
}

function multc(a, b){
    return cpol(a.r*b.r, a.φ+b.φ);
}

function multc_esc(λ, a){
    return cpol(λ*a.r, a.φ);
}

function divc(a, b){
    return cpol(a.r/b.r, a.φ-b.φ);
}

function invc(a){ // inversa d'un complexe
    return cpol(1/a.r, -a.φ);
}

function logc (nom, v){ // log de un numero complexe
    let log = "";
    log += nom + ": ";
    log += xs(v.x);
    if (v.y > 0) log += " + j" + xs(v.y);
    else if (v.y < 0) log += "-j" + xs(-v.y);
    log += "; ";
    log += xs(v.r) + "∠" + xs(v.φ) + "°\n";
    log = coma(log);
    return log;
}

function logcbi (v){ // log de un numero complexe només en binomial
    let log = "";
    log += xs(v.x);
    if (v.y > 0) log += " + j" + xs(v.y);
    else if (v.y < 0) log += "-j" + xs(-v.y);
    log = coma(log);
    return log;
}

function l(a){  // log abreviat a l totsol
    if (!a.toPrecision) return a;
    return coma(xs(a));
}

function ll(a, b = 4){ // log Latex
    return cl(xs(a, b));
}

function xs(a, b = 4){
    a = Number(a);
    if (a.toPrecision) a = a.toPrecision(b);
    return Number(a);
}

function coma(a){
    a = a + "";
    return a.replaceAll(".", ",");
}

function cl(a){ // coma per a latex
    return coma(a).replaceAll(",", "{,}");
}

function xsMap(a){
    a = xs(a);
    return a;
}


function nombreALletra(nombre) {
    const ascii = 97; // Código ASCII de 'a'
    if (nombre >= 1 && nombre <= 26) {
        // Convertir el número en el carácter correspondiente usando el código ASCII
        return String.fromCharCode(ascii + nombre - 1);
    } else {
        return null; // Retornar null si el número está fuera de rango
    }
}

function lletraANombre(lletra){
    return lletra.toLowerCase().charCodeAt(0) - 96;
}

</script>














<!--
/**********************************************************************
 * - Establir les puntuacions, que han de correspondre amb la quantitat
 * de respostes que l'alumne pot contestar.
 *
 * - Establir els paràmetres. En general serà una funció per a generar
 * nombres aleatoris, però també es poden fixar. Aquest últim cas és
 * interessant per a testejar els càlculs. IMPORTANT: Al finalitzar
 * tots els parametres hauran de concatenarse al vector parametres.
 *
 * -  El mateix succeeix amb els càlculs. Tot haura de volcar-se al
 * vector solucions.
 * *******************************************************************/
-->
